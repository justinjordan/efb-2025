{"mappings":";AAEA,QAAe,QAAQ;IAKF,IAAI,EAAE,GAAG;IAJrB,MAAM,EAAG,iBAAiB,CAAC;IAC3B,GAAG,EAAG,wBAAwB,CAAC;IAC/B,QAAQ,UAAS;gBAEL,IAAI,EAAE,GAAG;IAmB5B,OAAO;IACP,MAAM;IACN,OAAO,CAAC,CAAC,EAAE,aAAa;IACxB,WAAW,CAAC,CAAC,EAAE,UAAU;IACzB,SAAS,CAAC,CAAC,EAAE,UAAU;IACvB,WAAW,CAAC,CAAC,EAAE,UAAU,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM,EAAE,MAAM;IACzD,QAAQ;IACR,YAAY;IAEZ,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI;IACpC,QAAQ,CAAC,MAAM,CAAC,GAAG,EAAE,wBAAwB,GAAG,IAAI;IAEpD,WAAW;IAWX,UAAU;IAWV,WAAW,CAAC,CAAC,EAAE,aAAa;IAI5B,YAAY;IAMZ,eAAe,CAAC,CAAC,EAAE,UAAU;IAI7B,aAAa,CAAC,CAAC,EAAE,UAAU;IAI3B,eAAe,CAAC,CAAC,EAAE,UAAU;CAM9B;AM9ED,QAAA,MAAM;;;CAGL,CAAC;AAEF,mBAAmB,OAAO,CAAC,qBAAqB,CAAC,CAAC;AAElD;IAYW,MAAM,EAAE,iBAAiB;IAX3B,MAAM,aAAwB;IAC9B,OAAO,EAAE,WAAW,CAAC;IACrB,MAAM,EAAE,KAAK,EAAE,CAAM;IACrB,OAAO,UAAS;IAChB,OAAO,qDAA+B;IACtC,SAAS,0FAAiC;IAC1C,WAAW,6FAAmC;gBAK5C,MAAM,EAAE,iBAAiB,EAChC,OAAO,GAAE,WAA4B;IAYhC,KAAK;IAeL,IAAI;IAMJ,eAAe;IAIf,gBAAgB;IAIhB,SAAS,CAAC,KAAK,EAAE,KAAK;IAYtB,QAAQ;CAwEhB","sources":["src/src/types/State.ts","src/src/entities/Ball.ts","src/src/entities/Layer.ts","src/src/states/PauseState.ts","src/src/states/GameState.ts","src/src/states/LoaderState.ts","src/src/main.ts","src/main.ts"],"sourcesContent":[null,null,null,null,null,null,null,"import log from \"loglevel\";\nimport State from \"./types/State\";\nimport GameState from \"./states/GameState\";\nimport LoaderState from \"./states/LoaderState\";\nimport PubSub from \"pubsub-js\";\n\nconst defaultOptions = {\n  debug: false,\n  loader: false,\n};\n\ntype GameOptions = Partial<typeof defaultOptions>;\n\nexport default class Efb {\n  public logger = log.getLogger(\"Efb\");\n  public options: GameOptions;\n  public states: State[] = [];\n  public running = false;\n  public publish = PubSub.publish.bind(PubSub);\n  public subscribe = PubSub.subscribe.bind(PubSub);\n  public unsubscribe = PubSub.unsubscribe.bind(PubSub);\n\n  private lastUpdate = 0;\n\n  constructor(\n    public canvas: HTMLCanvasElement,\n    options: GameOptions = defaultOptions\n  ) {\n    this.options = { ...defaultOptions, ...options };\n\n    this.handleResize();\n    const resizeObserver = new ResizeObserver(() => this.handleResize());\n    resizeObserver.observe(this.canvas);\n\n    this.logger.setLevel(options.debug ? \"debug\" : \"silent\");\n    this.logger.debug(\"Efb initialized with options\", this.options);\n  }\n\n  public start() {\n    this.running = true;\n    this.logger.debug(\"Efb is running\");\n\n    // Add the first state\n    const state = this.options.loader\n      ? new LoaderState(this)\n      : new GameState(this);\n    this.states.push(state);\n    state.handleEnter();\n\n    // Start the game loop\n    requestAnimationFrame(this.loop.bind(this));\n  }\n\n  public stop() {\n    this.running = false;\n    this.states = [];\n    this.logger.debug(\"Efb is stopped\");\n  }\n\n  public getCurrentState() {\n    return this.states?.[this.states.length - 1];\n  }\n\n  public getPreviousState() {\n    return this.states?.[this.states.length - 2];\n  }\n\n  public pushState(state: State) {\n    const lastState = this.getCurrentState();\n\n    if (lastState) {\n      // Exit the last state before entering the new one\n      lastState.handleExit();\n    }\n\n    state.handleEnter();\n    this.states.push(state);\n  }\n\n  public popState() {\n    const lastState = this.states.pop();\n\n    if (lastState) {\n      // Exit the last state before entering the new one\n      lastState.handleExit();\n    }\n\n    const newState = this.getCurrentState();\n    newState.handleEnter();\n  }\n\n  private handleResize() {\n    this.canvas.width = this.canvas.clientWidth;\n    this.canvas.height = this.canvas.clientHeight;\n\n    this.logger.debug(\"Canvas resized to\", {\n      width: this.canvas.width,\n      height: this.canvas.height,\n    });\n\n    try {\n      this.states.forEach((state) => {\n        state?.handleResize();\n      });\n    } catch (error) {\n      this.logger.error(\"Error resizing current state\", error);\n    }\n  }\n\n  private loop(currentTime: number) {\n    let delta =\n      this.lastUpdate > 0 ? (currentTime - this.lastUpdate) / 1000 : 0;\n    this.lastUpdate = currentTime;\n\n    // Cancel the loop if the delta is too large (e.g. when tab is inactive)\n    if (delta > 1) {\n      delta = 0;\n    }\n\n    if (!this.running) {\n      this.logger.debug(\"Efb is not running, stopping loop\");\n      this.stop();\n      return;\n    }\n\n    if (this.states.length === 0) {\n      this.logger.warn(\"No states to run, stopping loop\");\n      this.stop();\n      return;\n    }\n\n    try {\n      const state = this.getCurrentState();\n      const ctx = this.canvas.getContext(\"2d\");\n\n      if (!ctx) {\n        throw new Error(\"Cannot get 2d context from canvas\");\n      }\n\n      // Update all states\n      state.update(delta);\n\n      // Render the current state\n      state.render(ctx);\n    } catch (error) {\n      this.logger.error(\"Error in game loop\", error);\n    }\n\n    // Call the loop again\n    requestAnimationFrame(this.loop.bind(this));\n  }\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}
{"mappings":";AAAA;IACE,KAAK,CAAC,EAAE,OAAO,CAAC;CACjB;ACFD,QAAe,QAAQ;IACrB,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI;IACpC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,iBAAiB,GAAG,IAAI;IAChD,QAAQ,CAAC,OAAO,IAAI,IAAI;IACxB,QAAQ,CAAC,MAAM,IAAI,IAAI;CACxB;AKID;IACE,MAAM,aAAwB;IAC9B,OAAO,EAAE,WAAW,CAAC;IACrB,MAAM,EAAE,KAAK,EAAE,CAAM;IACrB,OAAO,UAAS;gBAMG,MAAM,EAAE,iBAAiB,EAC1C,OAAO,GAAE,WAA4B;IAiBhC,KAAK;IAaL,IAAI;IAMJ,SAAS,CAAC,KAAK,EAAE,KAAK;IAOtB,QAAQ;CA0DhB","sources":["src/src/types/Options.ts","src/src/types/State.ts","src/src/entities/Ball.ts","src/src/entities/Layer.ts","src/src/states/PauseState.ts","src/src/states/GameState.ts","src/src/main.ts","src/main.ts"],"sourcesContent":[null,null,null,null,null,null,null,"import log from \"loglevel\";\nimport GameOptions from \"./types/Options\";\nimport State from \"./types/State\";\nimport GameState from \"./states/GameState\";\n\nconst defaultOptions = {\n  debug: false,\n};\n\nexport default class Efb {\n  logger = log.getLogger(\"Efb\");\n  options: GameOptions;\n  states: State[] = [];\n  running = false;\n\n  private lastUpdate = 0;\n  private isVisible = true;\n\n  constructor(\n    private readonly canvas: HTMLCanvasElement,\n    options: GameOptions = defaultOptions\n  ) {\n    this.options = { ...defaultOptions, ...options };\n\n    this.resetCanvas();\n    const resizeObserver = new ResizeObserver(() => this.resetCanvas());\n    resizeObserver.observe(this.canvas);\n\n    document.addEventListener(\"visibilitychange\", () => {\n      this.isVisible = document.visibilityState === \"visible\";\n      this.logger.debug(\"Visibility change\", this.isVisible);\n    });\n\n    this.logger.setLevel(options.debug ? \"debug\" : \"silent\");\n    this.logger.debug(\"Efb initialized with options\", this.options);\n  }\n\n  public start() {\n    this.running = true;\n    this.logger.debug(\"Efb is running\");\n\n    // Add the first state\n    const state = new GameState(this, this.canvas);\n    state.onEnter();\n    this.states.push(state);\n\n    // Start the game loop\n    requestAnimationFrame(this.loop.bind(this));\n  }\n\n  public stop() {\n    this.running = false;\n    this.states = [];\n    this.logger.debug(\"Efb is stopped\");\n  }\n\n  public pushState(state: State) {\n    const lastState = this.states[this.states.length - 1];\n    lastState.onExit();\n    state.onEnter();\n    this.states.push(state);\n  }\n\n  public popState() {\n    const lastState = this.states[this.states.length - 1];\n    lastState.onExit();\n    this.states.pop();\n    const newState = this.states[this.states.length - 1];\n    newState.onEnter();\n  }\n\n  private resetCanvas() {\n    this.canvas.width = this.canvas.clientWidth;\n    this.canvas.height = this.canvas.clientHeight;\n\n    const ctx = this.canvas.getContext(\"2d\");\n\n    if (!ctx) {\n      throw new Error(\"Cannot get 2d context from canvas\");\n    }\n\n    this.logger.debug(\"Canvas resized to\", {\n      width: this.canvas.width,\n      height: this.canvas.height,\n    });\n  }\n\n  private loop(currentTime: number) {\n    const delta =\n      this.lastUpdate > 0 ? (currentTime - this.lastUpdate) / 1000 : 0;\n    this.lastUpdate = currentTime;\n\n    if (!this.running) {\n      this.logger.debug(\"Efb is not running, stopping loop\");\n      this.stop();\n      return;\n    }\n\n    if (this.states.length === 0) {\n      this.logger.warn(\"No states to run, stopping loop\");\n      this.stop();\n      return;\n    }\n\n    try {\n      const state = this.states[this.states.length - 1];\n\n      if (this.isVisible) {\n        // Update all states\n        state.update(delta);\n\n        // Render all states\n        state.render(this.canvas);\n      }\n    } catch (error) {\n      this.logger.error(\"Error in game loop\", error);\n    }\n\n    // Call the loop again\n    requestAnimationFrame(this.loop.bind(this));\n  }\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}
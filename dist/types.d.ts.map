{"mappings":";AAAA;IACE,KAAK,CAAC,EAAE,OAAO,CAAC;CACjB;ACFD,QAAe,QAAQ;IACrB,MAAM,EAAG,iBAAiB,CAAC;IAC3B,YAAY,UAAQ;IAEpB,QAAQ,CAAC,YAAY,IAAI,IAAI;IAC7B,QAAQ,CAAC,MAAM,CAAC,KAAK,EAAE,MAAM,GAAG,IAAI;IACpC,QAAQ,CAAC,MAAM,CAAC,MAAM,EAAE,iBAAiB,GAAG,IAAI;IAChD,QAAQ,CAAC,OAAO,IAAI,IAAI;IACxB,QAAQ,CAAC,MAAM,IAAI,IAAI;CACxB;AKAD;IAUW,MAAM,EAAE,iBAAiB;IATlC,MAAM,aAAwB;IAC9B,OAAO,EAAE,WAAW,CAAC;IACrB,MAAM,EAAE,KAAK,EAAE,CAAM;IACrB,OAAO,UAAS;IAChB,SAAS,UAAQ;gBAKR,MAAM,EAAE,iBAAiB,EAChC,OAAO,GAAE,WAA4B;IAiBhC,KAAK;IAaL,IAAI;IAMJ,eAAe;IAIf,gBAAgB;IAIhB,SAAS,CAAC,KAAK,EAAE,KAAK;IAYtB,QAAQ;CAuEhB","sources":["src/src/types/Options.ts","src/src/types/State.ts","src/src/entities/Ball.ts","src/src/entities/Layer.ts","src/src/states/PauseState.ts","src/src/states/GameState.ts","src/src/main.ts","src/main.ts"],"sourcesContent":[null,null,null,null,null,null,null,"import log from \"loglevel\";\nimport GameOptions from \"./types/Options\";\nimport State from \"./types/State\";\nimport GameState from \"./states/GameState\";\n\nconst defaultOptions = {\n  debug: false,\n};\n\nexport default class Efb {\n  logger = log.getLogger(\"Efb\");\n  options: GameOptions;\n  states: State[] = [];\n  running = false;\n  isVisible = true;\n\n  private lastUpdate = 0;\n\n  constructor(\n    public canvas: HTMLCanvasElement,\n    options: GameOptions = defaultOptions\n  ) {\n    this.options = { ...defaultOptions, ...options };\n\n    this.handleResize();\n    const resizeObserver = new ResizeObserver(() => this.handleResize());\n    resizeObserver.observe(this.canvas);\n\n    document.addEventListener(\"visibilitychange\", () => {\n      this.isVisible = document.visibilityState === \"visible\";\n      this.logger.debug(\"Visibility change\", this.isVisible);\n    });\n\n    this.logger.setLevel(options.debug ? \"debug\" : \"silent\");\n    this.logger.debug(\"Efb initialized with options\", this.options);\n  }\n\n  public start() {\n    this.running = true;\n    this.logger.debug(\"Efb is running\");\n\n    // Add the first state\n    const state = new GameState(this);\n    state.onEnter();\n    this.states.push(state);\n\n    // Start the game loop\n    requestAnimationFrame(this.loop.bind(this));\n  }\n\n  public stop() {\n    this.running = false;\n    this.states = [];\n    this.logger.debug(\"Efb is stopped\");\n  }\n\n  public getCurrentState() {\n    return this.states?.[this.states.length - 1];\n  }\n\n  public getPreviousState() {\n    return this.states?.[this.states.length - 2];\n  }\n\n  public pushState(state: State) {\n    const lastState = this.getCurrentState();\n\n    if (lastState) {\n      // Exit the last state before entering the new one\n      lastState.onExit();\n    }\n\n    state.onEnter();\n    this.states.push(state);\n  }\n\n  public popState() {\n    const lastState = this.states.pop();\n\n    if (lastState) {\n      // Exit the last state before entering the new one\n      lastState.onExit();\n    }\n\n    const newState = this.getCurrentState();\n    newState.onEnter();\n  }\n\n  private handleResize() {\n    this.canvas.width = this.canvas.clientWidth;\n    this.canvas.height = this.canvas.clientHeight;\n\n    this.logger.debug(\"Canvas resized to\", {\n      width: this.canvas.width,\n      height: this.canvas.height,\n    });\n\n    // Resize current state\n    try {\n      const state = this.getCurrentState();\n      state?.handleResize();\n    } catch (error) {\n      this.logger.error(\"Error resizing current state\", error);\n    }\n  }\n\n  private loop(currentTime: number) {\n    let delta =\n      this.lastUpdate > 0 ? (currentTime - this.lastUpdate) / 1000 : 0;\n    this.lastUpdate = currentTime;\n\n    // Cancel the loop if the delta is too large (e.g. when tab is inactive)\n    if (delta > 1) {\n      delta = 0;\n    }\n\n    if (!this.running) {\n      this.logger.debug(\"Efb is not running, stopping loop\");\n      this.stop();\n      return;\n    }\n\n    if (this.states.length === 0) {\n      this.logger.warn(\"No states to run, stopping loop\");\n      this.stop();\n      return;\n    }\n\n    try {\n      const state = this.getCurrentState();\n\n      // Update all states\n      state.update(delta);\n\n      // Render all states\n      if (state.shouldRender && this.isVisible) {\n        state.render(this.canvas);\n      }\n\n      this.canvas.getContext(\"2d\")?.drawImage(state.canvas, 0, 0);\n    } catch (error) {\n      this.logger.error(\"Error in game loop\", error);\n    }\n\n    // Call the loop again\n    requestAnimationFrame(this.loop.bind(this));\n  }\n}\n"],"names":[],"version":3,"file":"types.d.ts.map"}